#!/usr/bin/env node

/**
 * Database Setup Script
 * Sets up the database schema and initial data for development
 */

require('dotenv').config()
const { Pool } = require('pg')
const fs = require('fs')
const path = require('path')

class DatabaseSetup {
  constructor() {
    this.pool = new Pool({
      host: process.env.DB_HOST || 'localhost',
      port: process.env.DB_PORT || 5432,
      database: process.env.DB_NAME || 'turbo_chatwoot_webhook',
      user: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASSWORD || '',
      ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
    })
  }

  /**
   * Main setup function
   */
  async setup() {
    console.log('üóÑÔ∏è  Database Setup for Turbo Chatwoot Webhook')
    console.log('')

    try {
      // Test connection
      await this.testConnection()

      // Run migrations
      await this.runMigrations()

      // Migrate environment variables to database
      await this.migrateEnvToDb()

      // Insert sample data
      await this.insertSampleData()

      // Verify setup
      await this.verifySetup()

      console.log('')
      console.log('‚úÖ Database setup completed successfully!')

    } catch (error) {
      console.error('‚ùå Database setup failed:', error.message)
      throw error
    } finally {
      await this.pool.end()
    }
  }

  /**
   * Test database connection
   */
  async testConnection() {
    console.log('üîå Testing database connection...')
    
    try {
      const result = await this.pool.query('SELECT NOW() as current_time')
      console.log(`‚úÖ Connected to database at ${result.rows[0].current_time}`)
    } catch (error) {
      console.error('‚ùå Database connection failed:', error.message)
      throw error
    }
  }

  /**
   * Run all migrations
   */
  async runMigrations() {
    console.log('üîÑ Running database migrations...')
    
    // Ensure migrations table exists
    await this.ensureMigrationsTable()
    
    const migrationsDir = path.join(__dirname, '..', 'migrations')
    const migrationFiles = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort()

    // Get executed migrations
    const executedMigrations = await this.getExecutedMigrations()
    
    // Find pending migrations
    const pendingMigrations = migrationFiles.filter(
      file => !executedMigrations.includes(file.replace('.sql', ''))
    )

    if (pendingMigrations.length === 0) {
      console.log('‚úÖ All migrations are up to date!')
      return
    }

    console.log(`üìã Found ${pendingMigrations.length} pending migrations:`)
    pendingMigrations.forEach(file => {
      console.log(`  - ${file}`)
    })
    console.log('')

    for (const file of pendingMigrations) {
      console.log(`  üìÑ Executing: ${file}`)
      
      const migrationPath = path.join(migrationsDir, file)
      const sqlContent = fs.readFileSync(migrationPath, 'utf8')
      
      await this.pool.query(sqlContent)
    }

    console.log(`‚úÖ ${pendingMigrations.length} migrations completed`)
  }

  /**
   * Ensure migrations table exists
   */
  async ensureMigrationsTable() {
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        version VARCHAR(50) UNIQUE NOT NULL,
        description TEXT,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `
    await this.pool.query(createTableSQL)
  }

  /**
   * Get executed migrations
   */
  async getExecutedMigrations() {
    try {
      const result = await this.pool.query('SELECT version FROM migrations ORDER BY version')
      return result.rows.map(row => row.version)
    } catch (error) {
      return []
    }
  }

  /**
   * Migrate environment variables to database if needed
   */
  async migrateEnvToDb() {
    console.log('üîÑ Checking for environment variables migration...')
    
    // Check if env variables are already migrated
    const envConfigs = await this.pool.query(`
      SELECT COUNT(*) as count 
      FROM configurations 
      WHERE key LIKE 'server.%' OR key LIKE 'security.%' OR key LIKE 'rateLimit.%' OR key LIKE 'logging.%'
    `)
    
    if (envConfigs.rows[0].count > 0) {
      console.log('‚úÖ Environment variables already migrated to database')
      return
    }

    console.log('üìÑ Migrating environment variables to database...')
    
    const envMappings = [
      // Server
      { env: 'PORT', dbKey: 'server.port', type: 'number' },
      { env: 'NODE_ENV', dbKey: 'server.nodeEnv', type: 'string' },
      
      // Security
      { env: 'ADMIN_API_KEY', dbKey: 'security.adminApiKey', type: 'string' },
      { env: 'ALLOWED_ORIGINS', dbKey: 'security.corsOrigins', type: 'string' },
      
      // Rate Limiting
      { env: 'RATE_LIMIT_WINDOW_MS', dbKey: 'rateLimit.windowMs', type: 'number' },
      { env: 'RATE_LIMIT_MAX', dbKey: 'rateLimit.max', type: 'number' },
      
      // Logging
      { env: 'LOG_LEVEL', dbKey: 'logging.level', type: 'string' },
      { env: 'LOG_FORMAT', dbKey: 'logging.format', type: 'string' }
    ]

    let migrated = 0
    let skipped = 0

    for (const mapping of envMappings) {
      const envValue = process.env[mapping.env]
      
      if (envValue && envValue !== '') {
        // Convert value based on type
        let value = envValue
        if (mapping.type === 'number') {
          value = Number(envValue)
        } else if (mapping.type === 'boolean') {
          value = envValue.toLowerCase() === 'true'
        }

        // Update database
        await this.pool.query(`
          UPDATE configurations 
          SET value = $1, type = $2, updated_at = NOW()
          WHERE key = $3
        `, [String(value), mapping.type, mapping.dbKey])

        console.log(`  ‚úÖ ${mapping.env} ‚Üí ${mapping.dbKey}`)
        migrated++
      } else {
        console.log(`  ‚è≠Ô∏è  ${mapping.env} (empty, skipped)`)
        skipped++
      }
    }

    console.log(`‚úÖ Migrated ${migrated} values, skipped ${skipped} empty values`)
    console.log('‚ÑπÔ∏è  Database connection configs remain in .env file for initial connection')
  }

  /**
   * Insert sample data for development
   */
  async insertSampleData() {
    console.log('üìù Inserting sample data...')
    
    // Check and create missing permissions
    console.log('  üîÑ Checking and creating missing permissions...')

    // Define all permissions
    const PERMISSIONS = [
      // User Management
      { name: 'users.create', description: 'T·∫°o ng∆∞·ªùi d√πng m·ªõi', resource: 'users', action: 'create' },
      { name: 'users.read', description: 'Xem danh s√°ch ng∆∞·ªùi d√πng', resource: 'users', action: 'read' },
      { name: 'users.update', description: 'C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng', resource: 'users', action: 'update' },
      { name: 'users.delete', description: 'X√≥a ng∆∞·ªùi d√πng', resource: 'users', action: 'delete' },
      { name: 'users.manage_roles', description: 'Qu·∫£n l√Ω vai tr√≤ ng∆∞·ªùi d√πng', resource: 'users', action: 'manage_roles' },
      { name: 'users.change_password', description: 'ƒê·ªïi m·∫≠t kh·∫©u ng∆∞·ªùi d√πng', resource: 'users', action: 'change_password' },

      // Role Management
      { name: 'roles.create', description: 'T·∫°o vai tr√≤ m·ªõi', resource: 'roles', action: 'create' },
      { name: 'roles.read', description: 'Xem danh s√°ch vai tr√≤', resource: 'roles', action: 'read' },
      { name: 'roles.update', description: 'C·∫≠p nh·∫≠t vai tr√≤', resource: 'roles', action: 'update' },
      { name: 'roles.delete', description: 'X√≥a vai tr√≤', resource: 'roles', action: 'delete' },
      { name: 'roles.manage_permissions', description: 'Qu·∫£n l√Ω quy·ªÅn c·ªßa vai tr√≤', resource: 'roles', action: 'manage_permissions' },

      // Permission Management
      { name: 'permissions.read', description: 'Xem danh s√°ch quy·ªÅn', resource: 'permissions', action: 'read' },
      { name: 'permissions.manage', description: 'Qu·∫£n l√Ω quy·ªÅn h·ªá th·ªëng', resource: 'permissions', action: 'manage' },

      // Telegram Bot Management
      { name: 'telegram.create', description: 'T·∫°o bot Telegram m·ªõi', resource: 'telegram', action: 'create' },
      { name: 'telegram.read', description: 'Xem danh s√°ch bot Telegram', resource: 'telegram', action: 'read' },
      { name: 'telegram.update', description: 'C·∫≠p nh·∫≠t bot Telegram', resource: 'telegram', action: 'update' },
      { name: 'telegram.delete', description: 'X√≥a bot Telegram', resource: 'telegram', action: 'delete' },
      { name: 'telegram.test', description: 'Test k·∫øt n·ªëi bot Telegram', resource: 'telegram', action: 'test' },
      { name: 'telegram.manage_webhooks', description: 'Qu·∫£n l√Ω webhook Telegram', resource: 'telegram', action: 'manage_webhooks' },

      // Chatwoot Account Management
      { name: 'chatwoot.create', description: 'T·∫°o t√†i kho·∫£n Chatwoot m·ªõi', resource: 'chatwoot', action: 'create' },
      { name: 'chatwoot.read', description: 'Xem danh s√°ch t√†i kho·∫£n Chatwoot', resource: 'chatwoot', action: 'read' },
      { name: 'chatwoot.update', description: 'C·∫≠p nh·∫≠t t√†i kho·∫£n Chatwoot', resource: 'chatwoot', action: 'update' },
      { name: 'chatwoot.delete', description: 'X√≥a t√†i kho·∫£n Chatwoot', resource: 'chatwoot', action: 'delete' },
      { name: 'chatwoot.test', description: 'Test k·∫øt n·ªëi Chatwoot', resource: 'chatwoot', action: 'test' },

      // Dify App Management
      { name: 'dify.create', description: 'T·∫°o ·ª©ng d·ª•ng Dify m·ªõi', resource: 'dify', action: 'create' },
      { name: 'dify.read', description: 'Xem danh s√°ch ·ª©ng d·ª•ng Dify', resource: 'dify', action: 'read' },
      { name: 'dify.update', description: 'C·∫≠p nh·∫≠t ·ª©ng d·ª•ng Dify', resource: 'dify', action: 'update' },
      { name: 'dify.delete', description: 'X√≥a ·ª©ng d·ª•ng Dify', resource: 'dify', action: 'delete' },
      { name: 'dify.test', description: 'Test k·∫øt n·ªëi Dify', resource: 'dify', action: 'test' },

      // Configuration Management
      { name: 'config.read', description: 'Xem c·∫•u h√¨nh h·ªá th·ªëng', resource: 'config', action: 'read' },
      { name: 'config.update', description: 'C·∫≠p nh·∫≠t c·∫•u h√¨nh h·ªá th·ªëng', resource: 'config', action: 'update' },

      // Mapping Management
      { name: 'mappings.create', description: 'T·∫°o mapping bot-account', resource: 'mappings', action: 'create' },
      { name: 'mappings.read', description: 'Xem danh s√°ch mapping', resource: 'mappings', action: 'read' },
      { name: 'mappings.update', description: 'C·∫≠p nh·∫≠t mapping', resource: 'mappings', action: 'update' },
      { name: 'mappings.delete', description: 'X√≥a mapping', resource: 'mappings', action: 'delete' },

      // System Management
      { name: 'system.dashboard', description: 'Truy c·∫≠p dashboard h·ªá th·ªëng', resource: 'system', action: 'dashboard' },
      { name: 'system.logs', description: 'Xem logs h·ªá th·ªëng', resource: 'system', action: 'logs' },
      { name: 'system.metrics', description: 'Xem metrics h·ªá th·ªëng', resource: 'system', action: 'metrics' },
      { name: 'system.settings', description: 'Qu·∫£n l√Ω c√†i ƒë·∫∑t h·ªá th·ªëng', resource: 'system', action: 'settings' },

      // Webhook Management
      { name: 'webhook.read', description: 'Xem webhook logs', resource: 'webhook', action: 'read' },
      { name: 'webhook.manage', description: 'Qu·∫£n l√Ω webhook', resource: 'webhook', action: 'manage' },

      // Conversation Management
      { name: 'conversations.read', description: 'Xem danh s√°ch cu·ªôc tr√≤ chuy·ªán', resource: 'conversations', action: 'read' },
      { name: 'conversations.manage', description: 'Qu·∫£n l√Ω cu·ªôc tr√≤ chuy·ªán', resource: 'conversations', action: 'manage' },

      // Message Management
      { name: 'messages.read', description: 'Xem tin nh·∫Øn', resource: 'messages', action: 'read' },
      { name: 'messages.send', description: 'G·ª≠i tin nh·∫Øn', resource: 'messages', action: 'send' },
      { name: 'messages.manage', description: 'Qu·∫£n l√Ω tin nh·∫Øn', resource: 'messages', action: 'manage' }
    ]

    // 1. Create super_admin role if not exists
    console.log('  üëë Creating super_admin role...')
    const existingRole = await this.pool.query('SELECT id FROM roles WHERE name = $1', ['super_admin'])
    if (existingRole.rows.length === 0) {
      await this.pool.query(`
        INSERT INTO roles (id, name, description, created_at, updated_at)
        VALUES (1, 'super_admin', 'Super Administrator with full system access', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      `)
      console.log('    ‚úÖ Super admin role created')
    } else {
      console.log('    ‚ö†Ô∏è  Super admin role already exists')
    }

    // 2. Create missing permissions
    console.log('  üîê Creating missing permissions...')
    let createdCount = 0
    let skippedCount = 0
    
    for (const permission of PERMISSIONS) {
      const existing = await this.pool.query('SELECT id FROM permissions WHERE name = $1', [permission.name])
      if (existing.rows.length === 0) {
        await this.pool.query(`
          INSERT INTO permissions (name, description, resource, action, created_at)
          VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
        `, [permission.name, permission.description, permission.resource, permission.action])
        createdCount++
      } else {
        skippedCount++
      }
    }
    
    console.log(`    ‚úÖ Created ${createdCount} new permissions, skipped ${skippedCount} existing`)

    // 3. Assign missing permissions to super_admin role
    console.log('  üîó Assigning missing permissions to super_admin...')
    const permissionsResult = await this.pool.query('SELECT id FROM permissions')
    let assignedCount = 0
    let skippedAssignCount = 0
    
    for (const permission of permissionsResult.rows) {
      const existing = await this.pool.query(
        'SELECT id FROM role_permissions WHERE role_id = 1 AND permission_id = $1', 
        [permission.id]
      )
      if (existing.rows.length === 0) {
        await this.pool.query(`
          INSERT INTO role_permissions (role_id, permission_id, created_at)
          VALUES (1, $1, CURRENT_TIMESTAMP)
        `, [permission.id])
        assignedCount++
      } else {
        skippedAssignCount++
      }
    }
    
    console.log(`    ‚úÖ Assigned ${assignedCount} new permissions, skipped ${skippedAssignCount} existing`)

    // 4. Create superadmin user if not exists
    console.log('  üë§ Creating superadmin user...')
    const existingUser = await this.pool.query('SELECT id FROM users WHERE username = $1', ['superadmin'])
    if (existingUser.rows.length === 0) {
      const bcrypt = require('bcrypt')
      const passwordHash = await bcrypt.hash('ThuanThuan@@1', 10)
      await this.pool.query(`
        INSERT INTO users (username, email, password_hash, full_name, is_active, created_at, updated_at)
        VALUES ('superadmin', 'thuanpt182@gmail.com', $1, 'Super Administrator', true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      `, [passwordHash])
      console.log('    ‚úÖ Super admin user created')
    } else {
      console.log('    ‚ö†Ô∏è  Super admin user already exists')
    }

    // 5. Assign super_admin role to superadmin user if not exists
    console.log('  üîó Assigning super_admin role to superadmin user...')
    const userResult = await this.pool.query('SELECT id FROM users WHERE username = $1', ['superadmin'])
    const userId = userResult.rows[0].id
    
    const existingUserRole = await this.pool.query(
      'SELECT id FROM user_roles WHERE user_id = $1 AND role_id = 1', 
      [userId]
    )
    if (existingUserRole.rows.length === 0) {
      await this.pool.query(`
        INSERT INTO user_roles (user_id, role_id, created_at)
        VALUES ($1, 1, CURRENT_TIMESTAMP)
      `, [userId])
      console.log('    ‚úÖ Super admin role assigned to user')
    } else {
      console.log('    ‚ö†Ô∏è  Super admin role already assigned to user')
    }

    console.log('‚úÖ Sample data and permissions inserted')
    console.log('üîë Super admin credentials:')
    console.log('   Username: superadmin')
    console.log('   Password: ThuanThuan@@1')
    console.log('   Email: thuanpt182@gmail.com')
  }

  /**
   * Verify setup
   */
  async verifySetup() {
    console.log('üîç Verifying database setup...')
    
    // Check tables
    const tablesResult = await this.pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      ORDER BY table_name
    `)

    console.log('üìã Database tables:')
    tablesResult.rows.forEach(row => {
      console.log(`  - ${row.table_name}`)
    })

    // Check configurations
    const configResult = await this.pool.query('SELECT COUNT(*) as count FROM configurations')
    console.log(`‚öôÔ∏è  Configuration entries: ${configResult.rows[0].count}`)

    // Check conversations
    const convResult = await this.pool.query('SELECT COUNT(*) as count FROM conversations')
    console.log(`üí¨ Sample conversations: ${convResult.rows[0].count}`)
  }

  /**
   * Show configuration values
   */
  async showConfigurations() {
    console.log('')
    console.log('‚öôÔ∏è  Current configurations:')
    
    try {
      const configs = await this.pool.query(`
        SELECT key, value, type, group_name, description 
        FROM configurations 
        ORDER BY group_name, key
      `)

      let currentGroup = null
      configs.rows.forEach(config => {
        if (config.group_name !== currentGroup) {
          currentGroup = config.group_name
          console.log(`\nüìÅ ${currentGroup.toUpperCase()} Configuration:`)
        }
        
        const displayValue = config.key.includes('Token') || config.key.includes('Key') || config.key.includes('Password')
          ? (config.value ? '***SET***' : 'NOT SET')
          : config.value
        console.log(`  ${config.key}: ${displayValue} (${config.type})`)
        if (config.description) {
          console.log(`    ‚îî‚îÄ ${config.description}`)
        }
      })
    } catch (error) {
      console.log('  ‚ö†Ô∏è  Could not load configurations:', error.message)
    }
  }
}

// CLI interface
if (require.main === module) {
  const command = process.argv[2] || 'setup'
  const setup = new DatabaseSetup()

  switch (command) {
    case 'setup':
      setup.setup()
        .then(() => {
          // Create new setup instance for showing configs
          const configSetup = new DatabaseSetup()
          return configSetup.showConfigurations()
        })
        .then(() => {
          console.log('')
          console.log('üöÄ Next steps:')
          console.log('1. Update your .env file with correct database credentials')
          console.log('2. Start the application: yarn start')
          console.log('3. Test the webhook endpoints')
          process.exit(0)
        })
        .catch(error => {
          console.error('Setup failed:', error.message)
          process.exit(1)
        })
      break

    case 'config':
      setup.testConnection()
        .then(() => setup.showConfigurations())
        .then(() => process.exit(0))
        .catch(error => {
          console.error('Failed to show configurations:', error.message)
          process.exit(1)
        })
      break

    default:
      console.log('Usage: node scripts/setup/database.js [setup|config]')
      console.log('')
      console.log('Commands:')
      console.log('  setup  - Run full database setup (default)')
      console.log('  config - Show current configurations')
      process.exit(1)
  }
}

module.exports = DatabaseSetup
